1.我们通过redis来实现对用户频率的限制
2.我们如何防止库存超卖问题 我们基于一个数据库的乐观锁来实现
{
and inventory>3 and version=#{version }  // 此时会对库存进行 -1 然后同时对版本号实现+1
}
//4. 秒杀抢购修改数据库如何减少数据库io操作

	非常靠谱的秒杀方案  基于Mq+库存令牌桶实现
	
	同时有10万个请求来实现秒杀， 此时商品的库存只有100个，  实现只需要修改库存100次
	{
	有10W-100个秒杀失败
	}
	方案实现流程  提前对应商品库存生成好对应的令牌
	提前生成好100个令牌 也就是100个令牌 在10W 个请求 中 只要谁能够获取到令牌 谁就能够执行减库存操作
	获取到秒杀令牌中，再使用Mq异步实现修改来秒杀去减库存
	=======================================================>
	
	呢如果支付失败 ，令牌同怎么重新生成
	=======================================================>
//->从redis中获取秒杀 的token
String sellToken=	generationToken.getListkeyToken(sellId)
//--->谁能拿到token 就把这个token放入到mq中  然后通过Mq异步实现秒杀扣库存

如果采用mq实现秒杀抢购，呢么秒杀接口会立马拿到秒杀结果么  ？
MQ 是一个异步的 帮我们解决流量削锋问题//

不会立马拿到结果 
所以此时会展示给用户一个 等待
我们在12306 抢票的时候 正在出票中....[等待10秒钟]// 此时会出单成功 或者是出单失败  或者说正在排队中 
通过Mq来修改我们的库存


//------------------------------------------> 
前端调用秒杀接口，如果秒杀成功的话 返回正在排队中
前端写一个定时器 使用秒杀token查询是否秒杀成功
--------------------------------------------------------------------------------------------------------------> 
秒杀接口异步实现的话 呢么返回结果为正在出票中....[等待10秒钟]// 此时会出单成功 或者是出单失败  或者说正在排队中 
呢么在界面当中我怎么知道我到底是排队成功呢 或者说前端怎么知道我秒杀成功呢
--->方案 前端调用秒杀接口，如果秒杀成功的话 返回正在排队中
		 前端写一个定时器 使用秒杀token查询是否秒杀成功>mq消费速度非常快的情况下
		  1.正在排队中 2.秒杀成功
--------------------------------------------------------------------------------------------------------------> 
100个库存 使用100个秒杀token  redis什么样的数据类型	redis key商品的库存id  value是一个集合List
1.给对应商品库存生成令牌
2.秒杀抢购访问接口 
{
1.    从redis中获取token  然后删除对应的token
//------>然后前端会写一个定时器来调用接口就是使用Phone和seckiiId 来查询秒杀状态
}
--------------------------------------------------------------------------------------------------------------------------------->

通过代码来实现秒杀
1.>采用redis数据库类型为list类型 key为商品库存id list是多个秒杀token
{
//----->限流实现 不应该放在秒杀接口当中  nginx实现 hystrix实现 //此时 不在接口中实现




}
-----------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------
我们可以通过生产者消息确认机制   来保证我们的消费一定确认消费了

因为你redis是单线程的 所以说此时你mq也是单线程的